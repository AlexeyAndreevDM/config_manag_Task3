# Ассемблер и интерпретатор для учебной виртуальной машины. Вариант №2.

### Этап 1: Перевод программы в промежуточное представление

#### Общее описание
Разработан ассемблер для учебной виртуальной машины (УВМ) вариант №2. На данном этапе реализован перевод программы из текстового представления в промежуточное представление. Ассемблер принимает на вход программу в формате JSON и преобразует ее во внутреннее представление в виде списка команд с полями A и B.

#### Спецификация УВМ
Архитектура учебной виртуальной машины включает следующие команды:

- **Загрузка константы** (opcode=22): загружает 20-битную константу в регистр-аккумулятор
- **Чтение из памяти** (opcode=62): читает значение из памяти по 11-битному адресу в регистр-аккумулятор  
- **Запись в память** (opcode=26): записывает значение из регистра-аккумулятора в память по 11-битному адресу
- **Умножение** (opcode=45): умножает значение в памяти на значение в регистре-аккумуляторе

#### Описание языка ассемблера
Программа представляет собой JSON-массив инструкций. Каждая инструкция - объект с полями:

```json
{
  "opcode": <код_операции>, "B": <операнд>
}
```

Диапазоны значений:
- Для команды загрузки константы (22): B = 0..1048575 (20 бит)
- Для остальных команд (62, 26, 45): B = 0..2047 (11 бит)

#### Описание функций и настроек
Основной класс Assembler содержит следующие методы:

- `parse_instruction(op)`: разбирает отдельную инструкцию из JSON, проверяет корректность кода операции и диапазонов операндов
- `assemble(input_file, test_mode)`: основной метод ассемблирования, читает входной файл, парсит инструкции и формирует промежуточное представление
- `display_internal_representation()`: выводит внутреннее представление программы в формате полей и значений, сравнивает с тестовыми примерами

#### Команды для запуска

**Основной ассемблер:**
```bash
python main.py <входной_файл.json> <выходной_файл.bin> [--test]
```

**Параметры:**
- `входной_файл.json` - файл с программой в формате JSON
- `выходной_файл.bin` - имя выходного бинарного файла (на данном этапе не создается)
- `--test` - необязательный флаг для включения режима тестирования

#### Примеры использования

**Пример входного файла program.json:**
```json
[
    {"opcode": 22, "B": 722},
    {"opcode": 62, "B": 541},
    {"opcode": 26, "B": 34},
    {"opcode": 45, "B": 94}
]
```

**Запуск в обычном режиме:**
```bash
python main.py program.json program.bin
```

**Запуск в режиме тестирования:**
```bash
python main.py program.json program.bin --test
```

**Ожидаемый вывод в режиме тестирования:**
```
Внутреннее представление программы:
Инструкция 0: A=22, B=722
Инструкция 1: A=62, B=541
Инструкция 2: A=26, B=34
Инструкция 3: A=45, B=94

Сравнение с тестовыми примерами из спецификации:
Тест 0: СОВПАДАЕТ (ожидалось A=22, B=722)
Тест 1: СОВПАДАЕТ (ожидалось A=62, B=541)
Тест 2: СОВПАДАЕТ (ожидалось A=26, B=34)
Тест 3: СОВПАДАЕТ (ожидалось A=45, B=94)

Ассемблирование завершено успешно
```

#### Тестирование
Для проверки корректности работы ассемблера создан набор тестовых файлов:
- `test1_correct.json` - корректная программа из спецификации
- `test2_error_opcode.json` - программа с неизвестным кодом операции
- `test3_error_range.json` - программа с выходом за диапазон значений
- `test4_empty.json` - пустая программа
- `test5_missing_field.json` - программа с отсутствующим полем
- `test6_invalid_json.json` - программа с неверным форматом JSON

Запуск всех тестов осуществляется командой:
```bash
python test.py
```

#### Требования этапа 1
Реализация соответствует всем требованиям этапа 1:
- CLI-приложение с аргументами командной строки
- Человекочитаемый язык ассемблера в формате JSON
- Поддержка всех команд спецификации УВМ
- Транслятор в промежуточное представление
- Вывод внутреннего представления в тестовом режиме
- Проверка корректности с тестовыми примерами из спецификации